<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–†–µ–Ω–¥–∑—é –æ–Ω–ª–∞–π–Ω</title>
  <style>
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      overflow: hidden;
      background: #f0f0f0; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
    }
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
    }
    .hidden { display: none !important; }
    
    /* --- –õ–æ–±—ñ --- */
    .lobby-container { text-align: center; background: white; padding: 30px 40px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.1); width: 320px; box-sizing: border-box; }
    .lobby-container .button-group { display: flex; flex-direction: column; gap: 15px; width: 100%; }
    .lobby-container button { font-size: 18px; padding: 12px 24px; cursor: pointer; border-radius: 8px; border: none; color: white; width: 100%; box-sizing: border-box; }
    #create-game-btn, #join-game-btn { background-color: #17a2b8; }
    #show-login-modal, #show-register-modal { background-color: #007bff; }
    #logout-btn { background-color: #dc3545; }
    #play-as-guest-btn { font-size: 20px; background-color: #28a745; }
    #user-info { margin-bottom: 15px; }
    
    /* --- –ú–æ–¥–∞–ª—å–Ω—ñ –≤—ñ–∫–Ω–∞ --- */
    .modal { position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; }
    .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 400px; border-radius: 10px; }
    .modal-content input { width: calc(100% - 22px); padding: 10px; margin: 5px 0 15px 0; }
    
    /* --- –ó–∞–≥–∞–ª—å–Ω—ñ —Å—Ç–∏–ª—ñ –≥—Ä–∏ --- */
    canvas { background: #f9d58a; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); cursor: pointer; touch-action: none; }
    .timer-box { border: 1px solid transparent; border-radius: 5px; transition: all 0.3s ease; padding: 10px; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1);}
    .timer-box.active { box-shadow: 0 0 10px rgba(40, 167, 69, 0.7), inset 0 0 15px rgba(40, 167, 69, 0.1); border-color: #28a745; }
    .timer-box h3 { text-align: center; margin: 5px 0 10px 0; border-bottom: 1px solid #eee; padding-bottom: 5px; font-size: 16px; }
    .current-time { font-size: 24px; font-weight: bold; text-align: center; color: #007bff; margin-bottom: 10px; }
    .time-list { list-style-type: decimal; padding-left: 25px; margin: 0; font-size: 14px; max-height: 150px; overflow-y: auto; }
    .total-time { text-align: center; font-weight: bold; margin-top: 10px; border-top: 1px solid #eee; padding-top: 5px; }
    #chat-container { display: flex; flex-direction: column; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 5px; }
    #chat-container h3 { text-align: center; margin: 10px 0; }
    #messages { flex-grow: 1; padding: 10px; overflow-y: auto; border-top: 1px solid #eee; border-bottom: 1px solid #eee; }
    #chat-form { display: flex; padding: 5px; }
    #chat-input { flex-grow: 1; border: 1px solid #ccc; border-radius: 3px; padding: 5px; }
    #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    #winner-modal { background: white; padding: 25px 40px; border-radius: 10px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    #chat-toast { position: fixed; top: -100px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 20px; z-index: 2000; transition: top 0.5s ease; text-align: center; max-width: 90%; }
    #chat-toast.show { top: 10px; }
    #chat-handle-outer { display: none; }
    body.in-game #chat-handle-outer { display: flex; }

    /* --- –°–¢–ò–õ–Ü –î–õ–Ø –î–ï–°–ö–¢–û–ü–Ü–í / –ü–õ–ê–ù–®–ï–¢–Ü–í (min-width: 1081px) --- */
    @media (min-width: 1081px) {
        #game-layout { display: flex; flex-direction: row; align-items: stretch; gap: 20px; padding: 20px; width: 100%; height: 100%; max-width: 1400px; box-sizing: border-box; margin: 0 auto; }
        #left-panel { width: 220px; display: flex; flex-direction: column; gap: 15px; }
        #stats-container { display: flex; flex-direction: column; gap: 15px; }
        #game-controls { padding: 10px; background: white; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        #game-controls button { width: 100%; margin-top: 5px; }
        #game-container { flex: 1; display: flex; justify-content: center; align-items: center; }
        canvas { width: auto; height: 100%; aspect-ratio: 1 / 1; }
        #chat-container { width: 250px; }
        #messages { height: calc(100% - 80px); }
        #chat-handle-outer, #chat-handle-inner { display: none !important; }
    }

    /* --- –°–¢–ò–õ–Ü –î–õ–Ø –ú–û–ë–Ü–õ–¨–ù–ò–• (–ì–û–†–ò–ó–û–ù–¢–ê–õ–¨) --- */
    @media (max-width: 1080px) and (orientation: landscape) {
      body { overflow: hidden; }
      #game-layout { display: flex; flex-direction: row; align-items: stretch; gap: 10px; padding: 10px; width: 100%; height: 100%; box-sizing: border-box; }
      #left-panel { width: 240px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
      #stats-container { display: flex; flex-direction: column; gap: 10px;}
      #game-controls button { width: 100%; margin-top: 5px; }
      #game-container { flex: 1; display: flex; justify-content: center; align-items: center; }
      canvas { width: auto; height: 100%; aspect-ratio: 1 / 1; }
      #chat-container { flex-grow: 1; }
      #messages { height: 150px; }
      #chat-handle-outer, #chat-handle-inner { display: none !important; }
    }
    
    /* --- –°–¢–ò–õ–Ü –î–õ–Ø –ú–û–ë–Ü–õ–¨–ù–ò–• (–ü–û–†–¢–†–ï–¢) --- */
    @media (max-width: 1080px) and (orientation: portrait) {
      body { overflow: auto; padding-top: 110px; box-sizing: border-box; }
      body.chat-open { overflow: hidden; }
      #game-layout { display: flex; flex-direction: column; height: calc(100vh - 110px); width: 100%; padding: 5px; box-sizing: border-box; gap: 10px; }
      #left-panel { order: 2; }
      #stats-container { position: fixed; top: 0; left: 0; width: 100%; height: auto; display: flex; flex-direction: row; justify-content: space-around; z-index: 100; border-radius: 0; padding: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); background: white; }
      .timer-box { width: 48%; margin-bottom: 0; background: transparent; box-shadow: none; padding: 0; }
      .time-list { display: none; }
      .total-time { font-size: 12px; }
      #game-container { order: 1; width: 100%; flex-grow: 1; display: flex; justify-content: center; align-items: center; }
      canvas { width: 100%; height: auto; aspect-ratio: 1 / 1; }
      #game-controls { width: 100%; text-align: center; }
      #chat-container { order: 3; position: fixed; top: -100%; left: 0; width: 100%; height: 70%; transition: top 0.4s ease; z-index: 1500; border-radius: 0 0 20px 20px; background: white; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
      #chat-container.open { top: 0; }
      #chat-handle-inner { display: flex; width: 80px; height: 25px; background: #ccc; position: absolute; bottom: -25px; left: 50%; transform: translateX(-50%); border-radius: 0 0 10px 10px; cursor: pointer; justify-content: center; align-items: center; z-index: 1501; }
      #chat-handle-inner::before { content: ''; width: 40px; height: 5px; background: #fff; border-radius: 5px; }
      body.in-game:not(.chat-open) #chat-handle-outer { position: fixed; top: 115px; left: 50%; transform: translateX(-50%); width: 80px; height: 25px; background: #ccc; border-radius: 0 0 10px 10px; cursor: pointer; justify-content: center; align-items: center; z-index: 1600; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
      body.in-game:not(.chat-open) #chat-handle-outer::before { content: ''; width: 40px; height: 5px; background: #fff; border-radius: 5px; }
    }
  </style>
</head>
<body>
  
  <div id="lobby" class="lobby-container">
    <h1>–†–µ–Ω–¥–∑—é</h1>
    <div id="user-info" class="hidden">
      <p>–í—ñ—Ç–∞—î–º–æ, <strong id="user-name-display"></strong>!</p>
    </div>
    <div class="button-group" id="auth-container">
      <button id="show-login-modal">–í—Ö—ñ–¥</button>
      <button id="show-register-modal">–†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è</button>
    </div>
    <div class="button-group hidden" id="game-actions">
      <button id="create-game-btn">–°—Ç–≤–æ—Ä–∏—Ç–∏ –≥—Ä—É</button>
      <button id="join-game-btn">–ü—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è –¥–æ –≥—Ä–∏</button>
    </div>
    <hr style="width:100%; margin: 20px 0;">
    <div class="button-group">
      <button id="play-as-guest-btn">–ì—Ä–∞—Ç–∏ —è–∫ –≥—ñ—Å—Ç—å</button>
    </div>
  </div>
  
  <div id="join-screen" class="lobby-container hidden">
    <h2>–í–≤–µ–¥—ñ—Ç—å –∫–æ–¥ –≥—Ä–∏</h2>
    <form id="join-form">
      <input type="number" id="game-code-input" placeholder="–ö–æ–¥ –∑ 3 —Ü–∏—Ñ—Ä" required>
      <button type="submit">–ü—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è</button>
    </form>
    <button id="back-to-lobby">–ù–∞–∑–∞–¥</button>
  </div>
  
  <div id="game-layout" class="hidden">
    <div id="left-panel">
        <div id="stats-container">
            <div id="black-timer-box" class="timer-box">
                <h3 id="black-player-name">–ß–æ—Ä–Ω—ñ (0)</h3>
                <div id="black-current-time" class="current-time">0.0—Å</div>
                <ol id="black-time-list" class="time-list"></ol>
                <div id="black-total-time" class="total-time">–í—Å—å–æ–≥–æ: 0.0—Å</div>
            </div>
            <div id="white-timer-box" class="timer-box">
                <h3 id="white-player-name">–ë—ñ–ª—ñ (0)</h3>
                <div id="white-current-time" class="current-time">0.0—Å</div>
                <ol id="white-time-list" class="time-list"></ol>
                <div id="white-total-time" class="total-time">–í—Å—å–æ–≥–æ: 0.0—Å</div>
            </div>
        </div>
        <div id="game-controls">
            <h2 id="turn-indicator">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</h2>
            <button id="reset">–ó–∞–≤–µ—Ä—à–∏—Ç–∏ –≥—Ä—É</button>
            <button id="fullscreen-btn">–ù–∞ –≤–µ—Å—å –µ–∫—Ä–∞–Ω</button>
        </div>
    </div>
    <div id="game-container">
      <canvas id="board" width="600" height="600"></canvas>
    </div>
    <div id="chat-container">
      <div id="chat-handle-inner"></div> 
      <h3>–Ü–≥—Ä–æ–≤–∏–π —á–∞—Ç</h3>
      <div id="messages"></div>
      <form id="chat-form">
        <input id="chat-input" type="text" placeholder="–í–∞—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è..." autocomplete="off">
        <button type="submit">¬ª</button>
      </form>
    </div>
  </div>

  <div id="overlay" class="hidden">
    <div id="winner-modal">
      <h2 id="winner-message"></h2>
      <div id="final-stats"></div>
      <div class="button-row">
        <button id="rematch-btn">–ì—Ä–∞—Ç–∏ —â–µ —Ä–∞–∑</button>
        <button id="back-to-lobby-from-game">–í –ª–æ–±—ñ</button>
      </div>
      <button id="close-winner-modal-btn" style="background-color: #6c757d; margin-top: 10px;">–ü–æ–¥–∏–≤–∏—Ç–∏—Å—å –¥–æ—à–∫—É</button>
    </div>
  </div>

  <div id="login-modal" class="modal hidden">
    <div class="modal-content">
      <h2>–í—Ö—ñ–¥</h2>
      <form id="login-form">
        <input type="email" id="login-email" placeholder="Email" required>
        <input type="password" id="login-password" placeholder="–ü–∞—Ä–æ–ª—å" required>
        <button type="submit">–£–≤—ñ–π—Ç–∏</button>
        <button type="button" class="close-modal">–ó–∞–∫—Ä–∏—Ç–∏</button>
      </form>
    </div>
  </div>
  <div id="register-modal" class="modal hidden">
    <div class="modal-content">
      <h2>–†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è</h2>
      <form id="register-form">
        <input type="text" id="register-name" placeholder="–í–∞—à–µ —ñ–º'—è" required>
        <input type="email" id="register-email" placeholder="Email" required>
        <input type="password" id="register-password" placeholder="–ü–∞—Ä–æ–ª—å" required>
        <button type="submit">–ó–∞—Ä–µ—î—Å—Ç—Ä—É–≤–∞—Ç–∏—Å—è</button>
        <button type="button" class="close-modal">–ó–∞–∫—Ä–∏—Ç–∏</button>
      </form>
    </div>
  </div>

  <div id="chat-toast"></div>
  <div id="chat-handle-outer"></div>
  
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getDatabase, ref, onValue, set, get, remove, serverTimestamp, onDisconnect, push, update } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBXnor_Y2N9HFNqHI7hs8HBF2MRxJFTIq4",
      authDomain: "rendzyu-ed6bf.firebaseapp.com",
      databaseURL: "https://rendzyu-ed6bf-default-rtdb.firebaseio.com",
      projectId: "rendzyu-ed6bf",
      storageBucket: "rendzyu-ed6bf.firebasestorage.app",
      messagingSenderId: "928258814163",
      appId: "1:928258814163:web:48cbcdfaa01f9f030fe426",
      measurementId: "G-SYK9RLDKQ5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);

    const lobbyDiv = document.getElementById('lobby'), authContainer = document.getElementById('auth-container'), userInfoDiv = document.getElementById('user-info'), userNameDisplay = document.getElementById('user-name-display'), gameActionsDiv = document.getElementById('game-actions'), playAsGuestBtn = document.getElementById('play-as-guest-btn'), loginModal = document.getElementById('login-modal'), registerModal = document.getElementById('register-modal'), loginForm = document.getElementById('login-form'), registerForm = document.getElementById('register-form'), joinScreenDiv = document.getElementById('join-screen'), createGameBtn = document.getElementById('create-game-btn'), joinGameBtn = document.getElementById('join-game-btn'), joinForm = document.getElementById('join-form'), gameCodeInput = document.getElementById('game-code-input'), backToLobbyBtn = document.getElementById('back-to-lobby'), gameLayoutDiv = document.getElementById('game-layout');

    let localPlayerName = localStorage.getItem('playerName') || '–ì—ñ—Å—Ç—å';

    function enterFullscreen() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        }
    }

    onAuthStateChanged(auth, user => {
      const guestButtonGroup = playAsGuestBtn.parentElement;
      if (user) {
        sessionStorage.removeItem('isPlayingAsGuest');
        const userRef = ref(db, `users/${user.uid}`);
        get(userRef).then((snapshot) => {
            const userData = snapshot.val() || {};
            localPlayerName = userData.name;
            localStorage.setItem('playerName', localPlayerName);
            userNameDisplay.textContent = `${localPlayerName} (–†–µ–π—Ç–∏–Ω–≥: ${userData.rating || 1200})`;
        });
        userInfoDiv.classList.remove('hidden'); gameActionsDiv.classList.remove('hidden'); guestButtonGroup.classList.add('hidden');
        authContainer.innerHTML = `<button id="logout-btn">–í–∏–π—Ç–∏</button>`;
        document.getElementById('logout-btn').addEventListener('click', () => signOut(auth));
      } else {
        localPlayerName = '–ì—ñ—Å—Ç—å';
        userInfoDiv.classList.add('hidden'); gameActionsDiv.classList.add('hidden'); guestButtonGroup.classList.remove('hidden');
        authContainer.innerHTML = `<button id="show-login-modal">–í—Ö—ñ–¥</button> <button id="show-register-modal">–†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è</button>`;
        document.getElementById('show-login-modal').addEventListener('click', () => loginModal.classList.remove('hidden'));
        document.getElementById('show-register-modal').addEventListener('click', () => registerModal.classList.remove('hidden'));
      }
    });

    document.querySelectorAll('.close-modal').forEach(btn => btn.addEventListener('click', () => { loginModal.classList.add('hidden'); registerModal.classList.add('hidden'); }));

    loginForm.addEventListener('submit', async (e) => { e.preventDefault(); try { await signInWithEmailAndPassword(auth, loginForm['login-email'].value, loginForm['login-password'].value); loginModal.classList.add('hidden'); } catch (error) { alert(`–ü–æ–º–∏–ª–∫–∞ –≤—Ö–æ–¥—É: ${error.message}`); } });
    registerForm.addEventListener('submit', async (e) => { e.preventDefault(); try { const userCredential = await createUserWithEmailAndPassword(auth, registerForm['register-email'].value, registerForm['register-password'].value); await set(ref(db, `users/${userCredential.user.uid}`), { name: registerForm['register-name'].value, rating: 1200 }); registerModal.classList.add('hidden'); } catch (error) { alert(`–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó: ${error.message}`); } });

    playAsGuestBtn.addEventListener('click', () => {
        sessionStorage.setItem('isPlayingAsGuest', 'true');
        let guestName = prompt("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —ñ–º'—è –¥–ª—è –≥—Ä–∏:", localStorage.getItem('playerName') || '–ì—ñ—Å—Ç—å') || '–ì—ñ—Å—Ç—å';
        localPlayerName = guestName;
        sessionStorage.setItem('guestNameForGame', guestName);
        localStorage.setItem('playerName', guestName);
        gameActionsDiv.classList.remove('hidden'); authContainer.classList.add('hidden'); playAsGuestBtn.parentElement.classList.add('hidden');
    });

    const urlParams = new URLSearchParams(window.location.search);
    const gameId = urlParams.get('game');
    if (gameId) { 
        document.body.classList.add('in-game');
        lobbyDiv.classList.add('hidden'); 
        joinScreenDiv.classList.add('hidden'); 
        gameLayoutDiv.classList.remove('hidden'); 
        initGame(gameId); 
    }

    createGameBtn.addEventListener('click', async () => {
        const newGameId = Math.floor(100 + Math.random() * 900).toString();
        const isGuest = sessionStorage.getItem('isPlayingAsGuest') === 'true' && !auth.currentUser;
        const initialGameData = { 
            current: 'black', 
            score: { black: 0, white: 0 },
            isGuestGame: isGuest
        };
        await set(ref(db, `games/${newGameId}`), initialGameData);
        window.location.href = `?game=${newGameId}`;
    });

    joinGameBtn.addEventListener('click', () => { lobbyDiv.classList.add('hidden'); joinScreenDiv.classList.remove('hidden'); });
    backToLobbyBtn.addEventListener('click', () => { 
        document.body.classList.remove('in-game');
        joinScreenDiv.classList.add('hidden'); 
        lobbyDiv.classList.remove('hidden'); 
    });

    joinForm.addEventListener('submit', async (e) => { 
        e.preventDefault(); 
        const code = gameCodeInput.value; 
        if (code && code.length === 3) { 
            const gameRef = ref(db, `games/${code}`); 
            const snapshot = await get(gameRef); 
            if (snapshot.exists() && snapshot.val().current) { 
                window.location.href = `?game=${code}`; 
            } else { 
                alert("–ì—Ä–∞ –∑ —Ç–∞–∫–∏–º –∫–æ–¥–æ–º –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞."); 
            } 
        } else { 
            alert("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–¥ –∑ 3 —Ü–∏—Ñ—Ä."); 
        } 
    });

    function initGame(currentGameId) {
      const canvas = document.getElementById("board"), ctx = canvas.getContext("2d"), 
            resetButton = document.getElementById("reset"), 
            fullscreenBtn = document.getElementById('fullscreen-btn'),
            turnIndicator = document.getElementById("turn-indicator"), 
            overlay = document.getElementById("overlay"), 
            winnerMessage = document.getElementById("winner-message"), 
            finalStatsDiv = document.getElementById('final-stats'), 
            rematchBtn = document.getElementById('rematch-btn'), 
            backToLobbyFromGameBtn = document.getElementById('back-to-lobby-from-game'), 
            closeWinnerModalBtn = document.getElementById('close-winner-modal-btn'), 
            messagesDiv = document.getElementById('messages'), 
            chatForm = document.getElementById('chat-form'), 
            chatInput = document.getElementById('chat-input'), 
            blackTimerBox = { name: document.getElementById('black-player-name'), currentTime: document.getElementById('black-current-time'), timeList: document.getElementById('black-time-list'), totalTime: document.getElementById('black-total-time') }, 
            whiteTimerBox = { name: document.getElementById('white-player-name'), currentTime: document.getElementById('white-current-time'), timeList: document.getElementById('white-time-list'), totalTime: document.getElementById('white-total-time') }, 
            chatContainer = document.getElementById('chat-container'), 
            chatHandleInner = document.getElementById('chat-handle-inner'), 
            chatHandleOuter = document.getElementById('chat-handle-outer'),
            chatToast = document.getElementById('chat-toast');
      
      let myPlayerId = sessionStorage.getItem('playerId');
      if (!myPlayerId) { myPlayerId = Date.now().toString() + Math.random().toString(); sessionStorage.setItem('playerId', myPlayerId); }
      
      let myRole = null, players = {}, currentTimerInterval = null, current = "black", lastMove = null, isMoveProcessing = false, toastTimeout;
      let isGameOver = false;
      const size = 15, cell = canvas.width / size;
      let board = Array.from({ length: size }, () => Array(size).fill(null));

      const gameRef = ref(db, `games/${currentGameId}`), movesRef = ref(db, `games/${currentGameId}/moves`), currentRef = ref(db, `games/${currentGameId}/current`), playersRef = ref(db, `games/${currentGameId}/players`), lastMoveRef = ref(db, `games/${currentGameId}/lastMove`), chatRef = ref(db, `games/${currentGameId}/chat`), winnerRef = ref(db, `games/${currentGameId}/winner`), scoreRef = ref(db, `games/${currentGameId}/score`), turnStartTimeRef = ref(db, `games/${currentGameId}/turnStartTime`), moveTimesRef = ref(db, `games/${currentGameId}/moveTimes`), gameHistoryRef = ref(db, `gamesHistory/${currentGameId}`);
      
      onValue(playersRef, (snapshot) => { 
        if (isGameOver) return;
        players = snapshot.val() || {}; 
        if (!myRole) assignRole(); 
        updateScoreDisplay(); 
        updateTurnIndicator();
        const blackPlayer = players.black, whitePlayer = players.white;
        if (blackPlayer && whitePlayer) {
            get(turnStartTimeRef).then(timeSnapshot => {
                if (!timeSnapshot.exists() && !isGameOver) { 
                    set(turnStartTimeRef, serverTimestamp()); 
                }
            });
        }
      });
      
      function assignRole() {
        const user = auth.currentUser;
        const playerUID = user ? user.uid : myPlayerId;
        const blackPlayer = players.black, whitePlayer = players.white;
        
        const nameToSet = user ? localPlayerName : (sessionStorage.getItem('guestNameForGame') || '–ì—ñ—Å—Ç—å');

        if (blackPlayer?.id === playerUID) myRole = 'black';
        else if (whitePlayer?.id === playerUID) myRole = 'white';
        else if (!blackPlayer) { myRole = 'black'; set(ref(db, `games/${currentGameId}/players/black`), { id: playerUID, name: nameToSet, isGuest: !user }); onDisconnect(ref(db, `games/${currentGameId}/players/black`)).remove(); }
        else if (!whitePlayer) { myRole = 'white'; set(ref(db, `games/${currentGameId}/players/white`), { id: playerUID, name: nameToSet, isGuest: !user }); onDisconnect(ref(db, `games/${currentGameId}/players/white`)).remove(); }
        else { myRole = 'spectator'; }
      }

      onValue(turnStartTimeRef, (snapshot) => {
        clearInterval(currentTimerInterval);
        blackTimerBox.currentTime.textContent = '0.0—Å'; whiteTimerBox.currentTime.textContent = '0.0—Å';
        if (isGameOver) return;
        
        const startTime = snapshot.val();
        if (startTime && players.black && players.white) {
            currentTimerInterval = setInterval(() => { const elapsed = ((Date.now() - startTime) / 1000).toFixed(1); if (current === 'black') blackTimerBox.currentTime.textContent = `${elapsed}—Å`; else whiteTimerBox.currentTime.textContent = `${elapsed}—Å`; }, 100);
        }
      });

      onValue(moveTimesRef, (snapshot) => { 
        const allMoveTimes = snapshot.val() || { black: {}, white: {} }; 
        updateStatsPanel('black', Object.values(allMoveTimes.black || {})); 
        updateStatsPanel('white', Object.values(allMoveTimes.white || {})); 
      });
      
      function updateScoreDisplay() {
        get(scoreRef).then((snapshot) => {
            const score = snapshot.val() || { black: 0, white: 0 };
            const blackName = players.black?.name || "–ß–æ—Ä–Ω—ñ", whiteName = players.white?.name || "–ë—ñ–ª—ñ";
            blackTimerBox.name.innerHTML = `<span class="player-name">${blackName}</span> (${score.black})`; 
            whiteTimerBox.name.innerHTML = `<span class="player-name">${whiteName}</span> (${score.white})`;
        });
      }

      function updateStatsPanel(player, times) {
        const box = player === 'black' ? blackTimerBox : whiteTimerBox;
        box.timeList.innerHTML = '';
        if (times.length === 0) { box.totalTime.textContent = '–í—Å—å–æ–≥–æ: 0.0—Å'; return; }
        const fastest = Math.min(...times), slowest = Math.max(...times);
        times.forEach(time => { const li = document.createElement('li'); li.textContent = `${time.toFixed(1)}—Å`; if (time === fastest) li.classList.add('fastest-move'); if (time === slowest) li.classList.add('slowest-move'); box.timeList.appendChild(li); });
        const total = times.reduce((sum, t) => sum + t, 0); box.totalTime.textContent = `–í—Å—å–æ–≥–æ: ${total.toFixed(1)}—Å`;
      }

      function drawBoard() {
        ctx.clearRect(0,0,canvas.width,canvas.height); ctx.strokeStyle="#000"; ctx.lineWidth=1;
        for(let i=0;i<size;i++){ ctx.beginPath(); ctx.moveTo(cell/2,cell/2+i*cell); ctx.lineTo(canvas.width-cell/2,cell/2+i*cell); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cell/2+i*cell,cell/2); ctx.lineTo(cell/2+i*cell,canvas.height-cell/2); ctx.stroke(); }
        for(let y=0;y<size;y++){ for(let x=0;x<size;x++){ if(board[y][x]){ const stoneX = cell/2+x*cell, stoneY = cell/2+y*cell; ctx.beginPath(); ctx.arc(stoneX,stoneY,cell*.4,0,Math.PI*2); ctx.fillStyle=board[y][x]; ctx.shadowColor="rgba(0,0,0,0.3)"; ctx.shadowBlur=5; ctx.fill(); ctx.shadowBlur=0; if(lastMove && lastMove.x === x && lastMove.y === y){ ctx.beginPath(); ctx.arc(stoneX,stoneY,cell*.15,0,Math.PI*2); ctx.fillStyle=board[y][x]==='black'?'white':'black'; ctx.fill(); } } } }
      }

      function checkWinner(x,y,c){ const d=[[[1,0],[-1,0]],[[0,1],[0,-1]],[[1,1],[-1,-1]],[[1,-1],[-1,1]]]; for(let dir of d){ let count=1; for(let[dx,dy] of dir){ let nx=x,ny=y; while(true){ nx+=dx;ny+=dy; if(nx<0||ny<0||nx>=size||ny>=size||board[ny][nx]!==c)break; count++; } } if(count>=5)return true; } return false; }
      
      async function onGameEnd(winnerColor) {
        const gameSnapshot = await get(gameRef);
        const game = gameSnapshot.val();
        if (!game || !game.players.black || !game.players.white) return;
        const { black: blackPlayer, white: whitePlayer } = game.players;
        const gameResult = { blackPlayer: { id: blackPlayer.id, name: blackPlayer.name }, whitePlayer: { id: whitePlayer.id, name: whitePlayer.name }, winner: winnerColor, score: game.score, timestamp: serverTimestamp() };
        await set(gameHistoryRef, gameResult);
        const updates = {};
        if (!blackPlayer.isGuest) { updates[`/users/${blackPlayer.id}/games/${currentGameId}`] = true; }
        if (!whitePlayer.isGuest) { updates[`/users/${whitePlayer.id}/games/${currentGameId}`] = true; }
        if (Object.keys(updates).length > 0) { await update(ref(db), updates); }
        if (!blackPlayer.isGuest && !whitePlayer.isGuest) {
            const pBlackRef = ref(db, `users/${blackPlayer.id}`), pWhiteRef = ref(db, `users/${whitePlayer.id}`);
            const pBlack = (await get(pBlackRef)).val(), pWhite = (await get(pWhiteRef)).val();
            const resBlack = winnerColor === 'black' ? 1 : 0;
            const [newRatingBlack, newRatingWhite] = calculateNewRatings(pBlack.rating, pWhite.rating, resBlack);
            await update(ref(db, `users/${blackPlayer.id}`), { rating: newRatingBlack });
            await update(ref(db, `users/${whitePlayer.id}`), { rating: newRatingWhite });
        }
      }

      function calculateNewRatings(ratingA, ratingB, resultA) {
          const K = 32; const expectedA = 1 / (1 + Math.pow(10, (ratingB - ratingA) / 400));
          const newRatingA = Math.round(ratingA + K * (resultA - expectedA));
          const newRatingB = ratingB - (newRatingA - ratingA);
          return [newRatingA, newRatingB];
      }
      
      async function showWinner(winnerColor) {
        clearInterval(currentTimerInterval);
        if (winnerColor === 'draw') {
            winnerMessage.textContent = "–ù–Ü–ß–ò–Ø!";
        } else {
            const winnerName = (players[winnerColor]?.name || (winnerColor === 'black' ? '–ß–æ—Ä–Ω—ñ' : '–ë—ñ–ª—ñ')).toUpperCase();
            winnerMessage.textContent = `–ü–ï–†–ï–ú–û–ñ–ï–¶–¨: ${winnerName}`;
        }
        
        const score = (await get(scoreRef)).val() || { black: 0, white: 0 };
        const moveTimesSnapshot = await get(moveTimesRef);
        const moveTimes = moveTimesSnapshot.val() || { black: {}, white: {} };
        const blackTotal = Object.values(moveTimes.black || {}).reduce((s, t) => s + t, 0).toFixed(1);
        const whiteTotal = Object.values(moveTimes.white || {}).reduce((s, t) => s + t, 0).toFixed(1);

        finalStatsDiv.innerHTML = `<p><strong>–§—ñ–Ω–∞–ª—å–Ω–∏–π —Ä–∞—Ö—É–Ω–æ–∫: ${score.black} : ${score.white}</strong></p><p>${players.black?.name || "–ß–æ—Ä–Ω—ñ"}: ${blackTotal}—Å</p><p>${players.white?.name || "–ë—ñ–ª—ñ"}: ${whiteTotal}—Å</p>`;
        overlay.classList.remove("hidden");
      }

      onValue(winnerRef, (snapshot) => { 
          const winner = snapshot.val(); 
          if (winner && !isGameOver) { 
            isGameOver = true;
            showWinner(winner); 
          } else if (!winner && isGameOver) {
            isGameOver = false;
            updateTurnIndicator();
            overlay.classList.add('hidden');
          }
      });
      onValue(movesRef,s=>{ const m=s.val()||{}; board=Array.from({length:size},()=>Array(size).fill(null)); for(let k in m){ const{x,y,color}=m[k]; board[y][x]=color; } drawBoard(); });
      onValue(lastMoveRef, s => { lastMove = s.val(); drawBoard(); });
      onValue(currentRef,s=>{ if(isGameOver) return; current=s.val()||"black"; updateTurnIndicator(); });

      function updateTurnIndicator() {
        if (!players.black || !players.white) {
            const waitingText = "–û—á—ñ–∫—É–≤–∞–Ω–Ω—è —Å—É–ø–µ—Ä–Ω–∏–∫–∞...";
            turnIndicator.innerHTML = waitingText;
            return;
        }

        if(isGameOver) {
          const gameOverText = "–ì—Ä—É –∑–∞–≤–µ—Ä—à–µ–Ω–æ";
          turnIndicator.innerHTML = gameOverText;
          return;
        }
        const turnPlayer = current === "black" ? players.black : players.white;
        const turnName = turnPlayer?.name || (current === "black" ? "–ß–æ—Ä–Ω–∏—Ö" : "–ë—ñ–ª–∏—Ö");
        let statusText = `–•—ñ–¥: ${turnName}`;
        if (myRole && myRole !== 'spectator') { statusText += `<br><small>(–í–∏ –≥—Ä–∞—î—Ç–µ –∑–∞ ${myRole === 'black' ? '—á–æ—Ä–Ω–∏—Ö' : '–±—ñ–ª–∏—Ö'})</small>`; }
        else if (myRole === 'spectator') { statusText += "<br><small>(–í–∏ –≥–ª—è–¥–∞—á)</small>"; }
        
        turnIndicator.innerHTML = statusText;

        if (current === 'black') {
            document.getElementById('black-timer-box').classList.add('active');
            document.getElementById('white-timer-box').classList.remove('active');
        } else {
            document.getElementById('white-timer-box').classList.add('active');
            document.getElementById('black-timer-box').classList.remove('active');
        }
      }
      
      async function handleInteraction(e) {
          e.preventDefault(); 
          if (!players.black || !players.white) return;

          if (isGameOver || myRole !== current || isMoveProcessing) return;
          
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;

          const canvasX = (clientX - rect.left) * scaleX;
          const canvasY = (clientY - rect.top) * scaleY;
          
          const x = Math.floor(canvasX / cell);
          const y = Math.floor(canvasY / cell);

          if (x < 0 || y < 0 || x >= size || y >= size || board[y][x]) return;

          isMoveProcessing = true;
          
          try {
              const startTime = (await get(turnStartTimeRef)).val();
              const moveDuration = startTime ? (Date.now() - startTime) / 1000 : 0;
              const move = { x, y, color: current };

              const updates = {};
              const newMoveKey = push(movesRef).key;
              updates[`/games/${currentGameId}/moves/${newMoveKey}`] = move;
              updates[`/games/${currentGameId}/lastMove`] = { x, y };
              
              const newTimeKey = push(ref(db, `games/${currentGameId}/moveTimes/${current}`)).key;
              updates[`/games/${currentGameId}/moveTimes/${current}/${newTimeKey}`] = moveDuration;
              
              let isWinningMove = false;
              if (checkWinner(x, y, current)) {
                  isWinningMove = true;
                  const currentScore = (await get(scoreRef)).val() || { black: 0, white: 0 };
                  currentScore[current]++;
                  updates[`/games/${currentGameId}/score`] = currentScore;
                  updates[`/games/${currentGameId}/winner`] = current;
              } else {
                  const allMovesSnapshot = await get(movesRef);
                  const movesCount = (allMovesSnapshot.exists() ? Object.keys(allMovesSnapshot.val()).length : 0) + 1;
                  if (movesCount >= size * size) {
                      updates[`/games/${currentGameId}/winner`] = 'draw';
                  } else {
                      updates[`/games/${currentGameId}/current`] = current === "black" ? "white" : "black";
                      updates[`/games/${currentGameId}/turnStartTime`] = serverTimestamp();
                  }
              }

              await update(ref(db), updates);

              if (isWinningMove) {
                  await onGameEnd(current);
              }

          } catch (error) {
              console.error("–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å —Ö–æ–¥—É:", error);
          } finally {
              isMoveProcessing = false;
          }
      }

      canvas.addEventListener("pointerup", handleInteraction);
      canvas.addEventListener("touchend", handleInteraction);
      
      chatForm.addEventListener('submit', e => { 
        e.preventDefault(); 
        const messageText = chatInput.value.trim(); 
        if (messageText) {
          const senderName = myRole === 'black' ? (players.black?.name || '–ì—ñ—Å—Ç—å') : (myRole === 'white' ? (players.white?.name || '–ì—ñ—Å—Ç—å') : localPlayerName);
          const senderId = auth.currentUser?.uid || myPlayerId;
          push(chatRef, { name: senderName, text: messageText, senderId: senderId }); 
          chatInput.value = ''; 
        } 
      });

      let isFirstChatLoad = true;
      onValue(chatRef, snapshot => { 
        messagesDiv.innerHTML = ''; 
        snapshot.forEach(childSnapshot => { 
            const message = childSnapshot.val(); 
            const p = document.createElement('p'); 
            const nameSpan = document.createElement('span'); 
            nameSpan.textContent = `${message.name}: `; 
            p.appendChild(nameSpan); p.append(document.createTextNode(message.text)); 
            messagesDiv.appendChild(p); 
            if (!isFirstChatLoad && message.senderId !== (auth.currentUser?.uid || myPlayerId)) {
                showChatToast(message);
            }
        }); 
        isFirstChatLoad = false;
        messagesDiv.scrollTop = messagesDiv.scrollHeight; 
      });

      function showChatToast(message) {
        clearTimeout(toastTimeout);
        chatToast.innerHTML = `<strong>${message.name}:</strong> ${message.text}`;
        chatToast.classList.add('show');
        toastTimeout = setTimeout(() => { chatToast.classList.remove('show'); }, 5000);
      }
      
      function exitToLobby() {
        document.body.classList.remove('in-game');
        remove(gameRef);
        window.location.href = window.location.pathname; 
      }
      
      async function startRematch() {
        const updates = {};
        updates[`/games/${currentGameId}/moves`] = null;
        updates[`/games/${currentGameId}/lastMove`] = null;
        updates[`/games/${currentGameId}/winner`] = null;
        updates[`/games/${currentGameId}/moveTimes`] = null;
        updates[`/games/${currentGameId}/current`] = "black";
        updates[`/games/${currentGameId}/turnStartTime`] = serverTimestamp();
        
        try {
            await update(ref(db), updates);
        } catch (error) {
            console.error("–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å —Ä–µ–≤–∞–Ω—à—É:", error);
            alert("–ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ—á–∞—Ç–∏ —Ä–µ–≤–∞–Ω—à.");
        }
      }
      
      function toggleChat() {
        chatContainer.classList.toggle('open');
        document.body.classList.toggle('chat-open');
      }

      chatHandleInner.addEventListener('click', toggleChat);
      chatHandleOuter.addEventListener('click', toggleChat);
      fullscreenBtn.addEventListener('click', enterFullscreen);

      resetButton.addEventListener("click", exitToLobby);
      
      rematchBtn.addEventListener("click", startRematch);
      backToLobbyFromGameBtn.addEventListener("click", exitToLobby);
      closeWinnerModalBtn.addEventListener('click', () => { overlay.classList.add('hidden'); });
      
      if (!document.getElementById('game-code-container')) {
        const codeContainer = document.createElement('div');
        codeContainer.id = 'game-code-container';
        codeContainer.style.display = 'flex';
        codeContainer.style.alignItems = 'center';
        codeContainer.style.justifyContent = 'center';
        codeContainer.style.marginTop = '10px';
        codeContainer.innerHTML = `
            <span id="game-code-display" style="font-size: 16px; font-weight: bold; background: #fff; padding: 5px 10px; border-radius: 5px 0 0 5px; border: 1px solid #ddd; border-right: none;">–ö–æ–¥ –≥—Ä–∏: ${currentGameId}</span>
            <button id="copy-code-btn" title="–ö–æ–ø—ñ—é–≤–∞—Ç–∏ –∫–æ–¥" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 0 5px 5px 0; background: #f0f0f0; cursor: pointer; font-size: 16px; line-height: 1;">üìã</button>
        `;
        document.getElementById('game-controls').appendChild(codeContainer);

        document.getElementById('copy-code-btn').addEventListener('click', () => {
            navigator.clipboard.writeText(currentGameId).then(() => {
                showChatToast({ name: '–°–∏—Å—Ç–µ–º–∞', text: '–ö–æ–¥ –≥—Ä–∏ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ!' });
            });
        });
      }
      
      drawBoard();
    }
  </script>
</body>
</html>