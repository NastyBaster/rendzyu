<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Рендзю онлайн</title>
  <style>
    body { display: flex; justify-content: center; align-items: center; flex-direction: column; height: 100vh; background: #f0f0f0; margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; }
    .hidden { display: none !important; }
    
    .lobby-container { text-align: center; background: white; padding: 40px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.1); }
    .lobby-container button { font-size: 20px; padding: 15px 30px; cursor: pointer; margin: 10px; border-radius: 8px; border: none; color: white; }
    #create-game-btn { background-color: #28a745; }
    #join-game-btn { background-color: #007bff; }
    #join-screen input { font-size: 24px; padding: 10px; text-align: center; width: 150px; margin-bottom: 10px; border: 2px solid #ccc; border-radius: 5px; }
    #join-screen button { background-color: #007bff; }
    #back-to-lobby { background-color: #6c757d; }

    #game-layout { display: flex; align-items: flex-start; gap: 20px; }
    #game-container { display: flex; flex-direction: column; align-items: center; }
    #game-code-display { font-size: 16px; font-weight: bold; background: #fff; padding: 5px 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ddd; }
    canvas { background: #f9d58a; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); cursor: pointer; }
    #turn-indicator { font-family: sans-serif; color: #333; height: 50px; margin-bottom: 5px; margin-top: 10px; text-align: center; }
    
    /* СТИЛІ ДЛЯ СТАТИСТИКИ І ЧАТУ */
    .side-panel { width: 200px; height: 600px; display: flex; flex-direction: column; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 5px; padding: 10px; box-sizing: border-box; }
    .timer-box { margin-bottom: 15px; }
    .timer-box h3 { text-align: center; margin: 5px 0 10px 0; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    .current-time { font-size: 24px; font-weight: bold; text-align: center; color: #007bff; margin-bottom: 10px; }
    .time-list { list-style-type: decimal; padding-left: 25px; margin: 0; font-size: 14px; max-height: 150px; overflow-y: auto; }
    .time-list li.fastest-move { color: green; font-weight: bold; }
    .time-list li.slowest-move { color: red; font-weight: bold; }
    .total-time { text-align: center; font-weight: bold; margin-top: 10px; border-top: 1px solid #eee; padding-top: 5px; }

    #chat-container { width: 250px; /* ... інші стилі чату ... */ }

    #overlay { position: fixed; /* ... інші стилі оверлею ... */ }
    #winner-modal { background: white; padding: 25px 40px; border-radius: 10px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    #winner-modal button { margin: 5px; }
    #final-stats { margin-top: 15px; text-align: left; font-size: 14px; }
  </style>
</head>
<body>

  <!-- Лобі, як і раніше -->
  <div id="lobby" class="lobby-container"> ... </div>
  <div id="join-screen" class="lobby-container hidden"> ... </div>

  <div id="game-layout" class="hidden">
    <!-- ↓↓↓ НОВА КОЛОНКА ДЛЯ СТАТИСТИКИ ↓↓↓ -->
    <div id="stats-container" class="side-panel">
      <div id="black-timer-box" class="timer-box">
        <h3 id="black-player-name">Чорні (0)</h3>
        <div id="black-current-time" class="current-time">0.0с</div>
        <ol id="black-time-list" class="time-list"></ol>
        <div id="black-total-time" class="total-time">Всього: 0.0с</div>
      </div>
      <div id="white-timer-box" class="timer-box">
        <h3 id="white-player-name">Білі (0)</h3>
        <div id="white-current-time" class="current-time">0.0с</div>
        <ol id="white-time-list" class="time-list"></ol>
        <div id="white-total-time" class="total-time">Всього: 0.0с</div>
      </div>
    </div>

    <div id="game-container">
      <canvas id="board" width="600" height="600"></canvas>
      <h2 id="turn-indicator">Завантаження...</h2>
      <button id="reset">Завершити гру</button>
    </div>

    <div id="chat-container" class="side-panel">
        <h3>Ігровий чат</h3>
        <div id="messages"></div>
        <form id="chat-form"> ... </form>
    </div>
  </div>

  <div id="overlay" class="hidden">
    <div id="winner-modal">
      <h2 id="winner-message"></h2>
      <div id="final-stats"></div> <!-- Для фінальної статистики -->
      <button id="rematch-btn">Грати ще раз</button>
      <button id="back-to-lobby-from-game">Повернутись в лобі</button>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getDatabase, ref, onValue, set, push, remove, onDisconnect, get, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

    const firebaseConfig = { /* ... Ваші дані ... */ };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    
    // ... Код логіки лобі залишається без змін ...

    function initGame(currentGameId) {
        // ... Отримуємо елементи сторінки ...
        const blackTimerBox = {
            name: document.getElementById('black-player-name'),
            currentTime: document.getElementById('black-current-time'),
            timeList: document.getElementById('black-time-list'),
            totalTime: document.getElementById('black-total-time'),
        };
        const whiteTimerBox = { /* ... аналогічно для білих ... */ };
        
        // ... Решта змінних ...
        let currentTimerInterval = null;

        // Нові посилання на Firebase
        const scoreRef = ref(db, `games/${currentGameId}/score`);
        const turnStartTimeRef = ref(db, `games/${currentGameId}/turnStartTime`);
        const moveTimesRef = ref(db, `games/${currentGameId}/moveTimes`);
        // ... Решта посилань ...

        // Запускаємо таймер, як тільки починається хід
        onValue(turnStartTimeRef, (snapshot) => {
            clearInterval(currentTimerInterval);
            const startTime = snapshot.val();
            if (startTime) {
                currentTimerInterval = setInterval(() => {
                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    if (current === 'black') blackTimerBox.currentTime.textContent = `${elapsed}с`;
                    else whiteTimerBox.currentTime.textContent = `${elapsed}с`;
                }, 100);
            }
        });

        // Оновлюємо статистику при зміні ходів
        onValue(moveTimesRef, (snapshot) => {
            const allMoveTimes = snapshot.val() || { black: [], white: [] };
            updateStatsPanel('black', allMoveTimes.black || []);
            updateStatsPanel('white', allMoveTimes.white || []);
        });

        // Оновлюємо рахунок
        onValue(scoreRef, (snapshot) => {
            const score = snapshot.val() || { black: 0, white: 0 };
            const blackName = players.black?.name || "Чорні";
            const whiteName = players.white?.name || "Білі";
            blackTimerBox.name.textContent = `${blackName} (${score.black})`;
            whiteTimerBox.name.textContent = `${whiteName} (${score.white})`;
        });
        
        // Функція для оновлення панелі статистики
        function updateStatsPanel(player, times) {
            const box = player === 'black' ? blackTimerBox : whiteTimerBox;
            box.timeList.innerHTML = '';
            if (times.length === 0) {
                box.totalTime.textContent = 'Всього: 0.0с';
                return;
            }

            const fastest = Math.min(...times);
            const slowest = Math.max(...times);
            
            times.forEach(time => {
                const li = document.createElement('li');
                li.textContent = `${time.toFixed(1)}с`;
                if (time === fastest) li.classList.add('fastest-move');
                if (time === slowest) li.classList.add('slowest-move');
                box.timeList.appendChild(li);
            });

            const total = times.reduce((sum, t) => sum + t, 0);
            box.totalTime.textContent = `Всього: ${total.toFixed(1)}с`;
        }
        
        // Логіка кліку по дошці
        canvas.addEventListener("click", async (e) => {
            if (myRole !== current || !overlay.classList.contains('hidden')) return;
            
            const startTimeSnapshot = await get(turnStartTimeRef);
            const startTime = startTimeSnapshot.val();
            const moveDuration = startTime ? (Date.now() - startTime) / 1000 : 0;

            const moveTimesSnapshot = await get(moveTimesRef);
            const currentMoveTimes = moveTimesSnapshot.val() || { black: [], white: [] };
            if (!currentMoveTimes[current]) currentMoveTimes[current] = [];
            currentMoveTimes[current].push(moveDuration);
            set(moveTimesRef, currentMoveTimes);

            // ... Решта логіки ходу (push(movesRef), set(lastMoveRef)) ...
            
            if (checkWinner(x, y, current)) {
                const scoreSnapshot = await get(scoreRef);
                const currentScore = scoreSnapshot.val() || { black: 0, white: 0 };
                currentScore[current]++;
                set(scoreRef, currentScore); // Оновлюємо рахунок
                set(winnerRef, current); // Оголошуємо переможця
                return;
            }
            
            set(currentRef, current === "black" ? "white" : "black");
            set(turnStartTimeRef, serverTimestamp()); // Запускаємо годинник для наступного гравця
        });

        // Оновлена функція показу переможця
        async function showWinner(winnerColor) {
            const winnerName = players[winnerColor]?.name || (winnerColor === 'black' ? 'Чорні' : 'Білі');
            const scoreSnapshot = await get(scoreRef);
            const finalScore = scoreSnapshot.val() || { black: 0, white: 0 };
            const moveTimesSnapshot = await get(moveTimesRef);
            const finalMoveTimes = moveTimesSnapshot.val() || { black: [], white: [] };
            
            const blackTotal = (finalMoveTimes.black || []).reduce((s, t) => s + t, 0).toFixed(1);
            const whiteTotal = (finalMoveTimes.white || []).reduce((s, t) => s + t, 0).toFixed(1);

            winnerMessage.textContent = `${winnerName} перемогли!`;
            document.getElementById('final-stats').innerHTML = `
                <p><strong>Фінальний рахунок: ${finalScore.black} : ${finalScore.white}</strong></p>
                <p>${players.black?.name || "Чорні"}: ${blackTotal}с</p>
                <p>${players.white?.name || "Білі"}: ${whiteTotal}с</p>
            `;
            overlay.classList.remove("hidden");
        }
        
        // Логіка для реваншу
        function startRematch() {
            // Скидаємо все, КРІМ рахунку (score) та гравців (players)
            remove(movesRef);
            set(currentRef, "black");
            set(turnStartTimeRef, serverTimestamp());
            remove(winnerRef);
            remove(lastMoveRef);
            remove(moveTimesRef); // Очищуємо історію часу
            overlay.classList.add("hidden");
        }
        
        rematchBtn.addEventListener("click", startRematch);
    }
  </script>
</body>
</html>