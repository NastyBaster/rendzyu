<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>–†–µ–Ω–¥–∑—é –æ–Ω–ª–∞–π–Ω</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      height: 100vh;
      background: #f0f0f0;
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    canvas {
      background: #f9d58a;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      cursor: pointer;
    }

    button {
      margin-top: 10px;
      padding: 8px 15px;
      font-size: 16px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    
    /* –°–¢–ò–õ–Ü –î–õ–Ø –ê–ü–ì–†–ï–ô–î–Ü–í */

    #turn-indicator {
      font-family: sans-serif;
      color: #333;
      height: 30px; /* –†–µ–∑–µ—Ä–≤—É—î–º–æ –º—ñ—Å—Ü–µ, —â–æ–± —Å—Ç–æ—Ä—ñ–Ω–∫–∞ –Ω–µ "—Å—Ç—Ä–∏–±–∞–ª–∞" */
      margin-bottom: 5px;
      margin-top: 20px;
    }

    .hidden {
      display: none !important;
    }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #winner-modal {
      background: white;
      padding: 25px 50px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }
    
    #winner-modal h2 {
        margin-top: 0;
    }

    #play-again {
        background-color: #4CAF50;
        color: white;
        border: none;
    }

  </style>
</head>
<body>

  <canvas id="board" width="600" height="600"></canvas>
  <h2 id="turn-indicator">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</h2>
  <button id="reset">–ù–æ–≤–∞ –≥—Ä–∞</button>

  <!-- –ú–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –¥–ª—è –ø–µ—Ä–µ–º–æ–∂—Ü—è -->
  <div id="overlay" class="hidden">
    <div id="winner-modal">
      <h2 id="winner-message"></h2>
      <button id="play-again">–ì—Ä–∞—Ç–∏ —â–µ —Ä–∞–∑</button>
    </div>
  </div>

  <script type="module">
    // –Ü–º–ø–æ—Ä—Ç—É—î–º–æ –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –∑ Firebase SDK
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getDatabase, ref, onValue, set, push, remove } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

    // üîπ –í–∞—à—ñ –¥–∞–Ω—ñ –∑ Firebase Console
    const firebaseConfig = {
      apiKey: "AIzaSyBXnor_Y2N9HFNqHI7hs8HBF2MRxJFTIq4",
      authDomain: "rendzyu-ed6bf.firebaseapp.com",
      databaseURL: "https://rendzyu-ed6bf-default-rtdb.firebaseio.com",
      projectId: "rendzyu-ed6bf",
      storageBucket: "rendzyu-ed6bf.firebasestorage.app",
      messagingSenderId: "928258814163",
      appId: "1:928258814163:web:48cbcdfaa01f9f030fe426",
      measurementId: "G-SYK9RLDKQ5"
    };

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // –û—Ç—Ä–∏–º—É—î–º–æ –µ–ª–µ–º–µ–Ω—Ç–∏ –∑—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–∏
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const resetButton = document.getElementById("reset");
    const turnIndicator = document.getElementById("turn-indicator");
    const overlay = document.getElementById("overlay");
    const winnerMessage = document.getElementById("winner-message");
    const playAgainButton = document.getElementById("play-again");

    const size = 15;
    const cell = canvas.width / size;
    let board = Array.from({ length: size }, () => Array(size).fill(null));
    let current = "black";

    // Firebase refs
    const movesRef = ref(db, "moves");
    const currentRef = ref(db, "current");

    // –ú–∞–ª—é—î–º–æ –¥–æ—à–∫—É
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      for (let i = 0; i < size; i++) {
        ctx.beginPath();
        ctx.moveTo(cell / 2, cell / 2 + i * cell);
        ctx.lineTo(canvas.width - cell / 2, cell / 2 + i * cell);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cell / 2 + i * cell, cell / 2);
        ctx.lineTo(cell / 2 + i * cell, canvas.height - cell / 2);
        ctx.stroke();
      }
      // –ú–∞–ª—é—î–º–æ –∫–∞–º–µ–Ω—ñ
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x]) {
            ctx.beginPath();
            ctx.arc(cell / 2 + x * cell, cell / 2 + y * cell, cell * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = board[y][x];
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 5;
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }
      }
    }

    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–µ—Ä–µ–º–æ–∂—Ü—è
    function checkWinner(x, y, color) {
      const directions = [
        [[1, 0], [-1, 0]],   // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å
        [[0, 1], [0, -1]],   // –≤–µ—Ä—Ç–∏–∫–∞–ª—å
        [[1, 1], [-1, -1]],  // –¥—ñ–∞–≥–æ–Ω–∞–ª—å \
        [[1, -1], [-1, 1]]   // –¥—ñ–∞–≥–æ–Ω–∞–ª—å /
      ];
      for (let dir of directions) {
        let count = 1;
        for (let [dx, dy] of dir) {
          let nx = x, ny = y;
          while (true) {
            nx += dx;
            ny += dy;
            if (nx < 0 || ny < 0 || nx >= size || ny >= size) break;
            if (board[ny][nx] === color) count++;
            else break;
          }
        }
        if (count >= 5) return true;
      }
      return false;
    }

    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–æ–∫–∞–∑—É –≤—ñ–∫–Ω–∞ –ø–µ—Ä–µ–º–æ–∂—Ü—è
    function showWinner(player) {
      const winnerName = player === 'black' ? '–ß–æ—Ä–Ω—ñ' : '–ë—ñ–ª—ñ';
      winnerMessage.textContent = `${winnerName} –ø–µ—Ä–µ–º–æ–≥–ª–∏!`;
      overlay.classList.remove("hidden");
    }

    // –°–ª—É—Ö–∞—î–º–æ –±–∞–∑—É –¥–∞–Ω–∏—Ö –¥–ª—è —Ö–æ–¥—ñ–≤
    onValue(movesRef, snapshot => {
      const moves = snapshot.val() || {};
      board = Array.from({ length: size }, () => Array(size).fill(null));
      for (let key in moves) {
        const { x, y, color } = moves[key];
        board[y][x] = color;
      }
      drawBoard();
    });

    // –°–ª—É—Ö–∞—î–º–æ –±–∞–∑—É –¥–∞–Ω–∏—Ö –¥–ª—è —á–µ—Ä–≥–∏ —Ö–æ–¥—É
    onValue(currentRef, snapshot => {
      current = snapshot.val() || "black";
      const turnName = current === "black" ? "—á–æ—Ä–Ω–∏—Ö" : "–±—ñ–ª–∏—Ö";
      turnIndicator.textContent = `–•—ñ–¥ ${turnName}`;
    });

    // –û–±—Ä–æ–±–∫–∞ –∫–ª—ñ–∫—É –ø–æ –¥–æ—à—Ü—ñ
    canvas.addEventListener("click", e => {
      // –ù–µ –¥–æ–∑–≤–æ–ª—è—î–º–æ —Ö–æ–¥–∏—Ç–∏, —è–∫—â–æ –≥—Ä–∞ –∑–∞–∫—ñ–Ω—á–µ–Ω–∞ (–≤—ñ–∫–Ω–æ –ø–µ—Ä–µ–º–æ–∂—Ü—è –≤—ñ–¥–∫—Ä–∏—Ç–æ)
      if (!overlay.classList.contains('hidden')) {
          return;
      }

      const rect = canvas.getBoundingClientRect();
      const x = Math.round((e.clientX - rect.left - cell / 2) / cell);
      const y = Math.round((e.clientY - rect.top - cell / 2) / cell);
      if (x < 0 || y < 0 || x >= size || y >= size) return;

      if (!board[y][x]) {
        const move = { x, y, color: current };
        push(movesRef, move);
        if (checkWinner(x, y, current)) {
          setTimeout(() => {
            showWinner(current);
          }, 100);
          return;
        }
        set(currentRef, current === "black" ? "white" : "black");
      }
    });

    function resetGame() {
        remove(movesRef);
        set(currentRef, "black");
        overlay.classList.add("hidden"); // –•–æ–≤–∞—î–º–æ –≤—ñ–∫–Ω–æ –ø–µ—Ä–µ–º–æ–∂—Ü—è
    }

    // –ù–æ–≤–∞ –≥—Ä–∞ (–∫–Ω–æ–ø–∫–∞ –ø—ñ–¥ –¥–æ—à–∫–æ—é)
    resetButton.addEventListener("click", resetGame);

    // –ù–æ–≤–∞ –≥—Ä–∞ (–∫–Ω–æ–ø–∫–∞ —É –≤—ñ–∫–Ω—ñ –ø–µ—Ä–µ–º–æ–∂—Ü—è)
    playAgainButton.addEventListener("click", resetGame);

    drawBoard();
  </script>
</body>
</html>
